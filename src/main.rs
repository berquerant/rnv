mod cmd;
mod entry;
mod git;
mod iox;
use crate::git::Git;
use anyhow::{Result, ensure};
use clap::{self, Args, Parser, Subcommand};
use std::io::Write;
use std::path::PathBuf;

/// Generate renovatable line for git repository.
#[derive(Debug, Parser)]
#[command(name = "rnv")]
#[command(version, about)]
struct Cli {
    /// Path to the target repository.
    #[arg(value_name = "DIR", num_args = 1)]
    repo: PathBuf,
    /// Git command.
    #[arg(long = "git", default_value = "git")]
    git: String,
    #[command(subcommand)]
    command: Commands,
}

#[derive(Debug, Subcommand)]
enum Commands {
    /// Generate renovatable line.
    ///
    /// Use the current commit hash as an original commit hash.
    /// Renovatable line is like:
    ///
    ///   straight=ID depName=DEPNAME datasource=DATASOURCE value=TAG
    ///
    /// rnv identifies renovate setting by ID.
    /// ID will be the directory name of the repository.
    ///
    /// For renovate, add the following element to custom_managers:
    ///
    ///   {
    ///     "customType": "regex",
    ///     "description": "Generated by rnv",
    ///     "fileMatch": ["LOCK_FILE"],
    ///     "matchStrings": ["depName=(?<depName>.+) datasource=(?<datasource>[a-z-]+) value=(?<currentValue>.+)"]
    ///   }
    #[command(about, verbatim_doc_comment)]
    Gen {
        /// Override ID.
        #[arg(short = 'i', long = "id")]
        id: Option<String>,
        /// Override the original commit hash.
        #[arg(short = 'c')]
        commit: Option<String>,
    },
    /// Get the commit hash from the renovatable line.
    ///
    /// Read renovate lines from stdin.
    /// Display the commit hash that corresponds to the setting with a matching ID.
    /// See gen command for ID.
    #[command(about, verbatim_doc_comment)]
    Lock {
        /// Override ID.
        /// See gen command.
        #[arg(short = 'i', long = "id")]
        id: Option<String>,
        /// Read renovatable line from the file instead of stdin.
        #[arg(short = 'l', long = "lock")]
        lock_file: Option<PathBuf>,
    },
    /// Batch operations.
    #[command(about, verbatim_doc_comment)]
    Batch(BatchArgs),
}

#[derive(Debug, Args)]
struct BatchArgs {
    /// Exit on the first failure.
    #[arg(short = 'f', long = "failfast")]
    fail_fast: bool,
    #[command(subcommand)]
    command: BatchCommands,
}

#[derive(Debug, Subcommand)]
enum BatchCommands {
    /// Generate renovatable lines over the directories within DIR.
    #[command(about, verbatim_doc_comment)]
    Gen,
    /// Get commit hashes from renovatable lines over the directories within DIR.
    ///
    /// Output format:
    ///
    ///   ID COMMIT
    #[command(about, verbatim_doc_comment)]
    Lock {
        /// Read renovatable lines from the file instead of stdin.
        #[arg(short = 'l', long = "lock")]
        lock_file: Option<PathBuf>,
    },
}

fn main() -> Result<()> {
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format(|buf, record| writeln!(buf, "[{}] {}", record.level(), record.args()))
        .init();
    let args = Cli::parse();
    ensure!(args.repo.exists(), "repo is not exist");
    ensure!(args.repo.is_dir(), "repo is not a directory");

    match args.command {
        Commands::Gen { id, commit } => {
            let default_id = cmd::default_renovate_id(&args.repo)?;
            let git = Git::new(&args.repo, &args.git);
            let renovate_id = id.unwrap_or(default_id);
            cmd::generate_renovate_setting(git, &renovate_id, commit)
        }
        Commands::Lock { id, lock_file } => {
            let default_id = cmd::default_renovate_id(&args.repo)?;
            let git = Git::new(&args.repo, &args.git);
            let renovate_id = id.unwrap_or(default_id);
            cmd::get_lock(git, &renovate_id, lock_file)
        }
        Commands::Batch(batch_args) => match batch_args.command {
            BatchCommands::Gen => {
                cmd::batch_generate_renovate_settings(&args.repo, &args.git, batch_args.fail_fast)
            }
            BatchCommands::Lock { lock_file } => {
                cmd::batch_get_lock(&args.repo, &args.git, lock_file, batch_args.fail_fast)
            }
        },
    }
}
